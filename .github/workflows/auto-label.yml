name: Auto Label Issues and PRs

on:
  issues:
    types: [opened, edited, reopened]
  pull_request:
    types: [opened, edited, reopened, synchronize]
  workflow_dispatch:

permissions:
  issues: write
  pull-requests: write
  contents: read
  checks: write

jobs:
  auto-label:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create status check (PR only)
        if: github.event_name == 'pull_request'
        id: status-check
        uses: actions/github-script@v7
        with:
          script: |
            const { data: check } = await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'Auto Label',
              head_sha: context.payload.pull_request.head.sha,
              status: 'in_progress',
              output: {
                title: 'Auto Label',
                summary: 'Analyzing PR and applying labels...'
              }
            });
            core.setOutput('check_run_id', check.id);
            return check.id;

      - name: Auto-label based on content
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue || context.payload.pull_request;
            const issueName = issue.title.toLowerCase();
            const issueBody = (issue.body || '').toLowerCase();
            const labels = [];

            // Priority Labels (using org emoji labels)
            if (issueName.includes('critical') || issueName.includes('urgent') || issueBody.includes('critical')) {
              labels.push('ðŸš¨Priority:CRITICAL');
            } else if (issueName.includes('high priority') || issueBody.includes('high priority')) {
              labels.push('ðŸ”´Priority:HIGH');
            } else if (issueName.includes('low priority') || issueBody.includes('low priority')) {
              labels.push('ðŸŸ¢Priority:LOW');
            } else {
              labels.push('ðŸŸ Priority:MEDIUM');
            }

            // Type Labels
            if (issueName.includes('bug') || issueName.includes('fix') || issueName.includes('error')) {
              labels.push('bug');
            } else if (issueName.includes('feature') || issueName.includes('add') || issueName.includes('feat')) {
              labels.push('âœ¨FEATURE');
            } else if (issueName.includes('docs') || issueName.includes('documentation')) {
              labels.push('documentation');
            } else if (issueName.includes('refactor') || issueName.includes('cleanup')) {
              labels.push('â™»ï¸REFACTOR');
            } else if (issueName.includes('test') || issueName.includes('testing')) {
              labels.push('ðŸ§ªTESTING');
            }

            // Hotfix detection
            if (issueName.includes('hotfix') || issueBody.includes('hotfix') || issueName.includes('urgent fix')) {
              labels.push('ðŸ”¥HOTFIX');
            }

            // Breaking changes
            if (issueName.includes('breaking') || issueBody.includes('breaking change')) {
              labels.push('ðŸ’¥BREAKING-CHANGE');
            }

            // Component Labels
            if (issueName.includes('ui') || issueName.includes('component') || issueBody.includes('component')) {
              labels.push('component:ui');
            }
            if (issueName.includes('engine') || issueName.includes('game logic') || issueBody.includes('game logic')) {
              labels.push('component:engine');
            }
            if (issueName.includes('animation') || issueBody.includes('animation')) {
              labels.push('component:animation');
            }
            if (issueName.includes('state') || issueName.includes('store') || issueBody.includes('zustand')) {
              labels.push('component:state');
            }
            if (issueName.includes('build') || issueName.includes('vite') || issueName.includes('config')) {
              labels.push('component:build');
            }

            // Status Labels (using org emoji labels)
            if (context.payload.pull_request) {
              if (context.payload.pull_request.draft) {
                labels.push('ðŸŽ¯IN-PROGRESS');
              } else {
                labels.push('ðŸ‘€NEEDS-REVIEW');
              }
            }

            // Area Labels (using org emoji labels)
            if (issueName.includes('security') || issueBody.includes('security') || issueBody.includes('vulnerability')) {
              labels.push('ðŸ”’SECURITY');
            }
            if (issueName.includes('performance') || issueBody.includes('performance') || issueName.includes('optimize')) {
              labels.push('ðŸ“ˆIMPROVEMENT');
            }
            if (issueName.includes('accessibility') || issueName.includes('a11y') || issueBody.includes('accessibility')) {
              labels.push('area:accessibility');
            }

            // Additional area detection
            if (issueName.includes('design') || issueBody.includes('design')) {
              labels.push('ðŸŽ¨DESIGN');
            }
            if (issueName.includes('compliance') || issueBody.includes('compliance') || issueBody.includes('regulatory')) {
              labels.push('ðŸ”COMPLIANCE');
            }
            if (issueName.includes('audit') || issueBody.includes('audit')) {
              labels.push('ðŸ›¡ï¸AUDIT');
            }

            // Good First Issue
            if (issueName.includes('good first issue') || issueBody.includes('good first issue') || issueName.includes('beginner')) {
              labels.push('good first issue');
            }

            // Blackjack-specific Labels
            if (issueName.includes('card') || issueName.includes('deck') || issueBody.includes('card')) {
              labels.push('game:cards');
            }
            if (issueName.includes('bet') || issueName.includes('chip') || issueBody.includes('betting')) {
              labels.push('game:betting');
            }
            if (issueName.includes('dealer') || issueBody.includes('dealer')) {
              labels.push('game:dealer');
            }
            if (issueName.includes('split') || issueName.includes('double') || issueBody.includes('split') || issueBody.includes('double down')) {
              labels.push('game:actions');
            }

            // Dependencies
            if (issueName.includes('dependency') || issueName.includes('upgrade') || issueName.includes('update package')) {
              labels.push('dependencies');
            }

            // Remove duplicates
            const uniqueLabels = [...new Set(labels)];

            // Apply labels
            if (uniqueLabels.length > 0) {
              if (context.payload.issue) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: uniqueLabels
                });
              } else if (context.payload.pull_request) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  labels: uniqueLabels
                });
              }

              console.log(`Applied labels: ${uniqueLabels.join(', ')}`);
            }

      - name: Label based on file changes (PRs only)
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });

            const labels = [];
            const filenames = files.map(f => f.filename);

            // Check for specific file patterns
            if (filenames.some(f => f.startsWith('src/components/'))) {
              labels.push('component:ui');
              labels.push('front-end');
            }
            if (filenames.some(f => f.startsWith('src/engine/'))) {
              labels.push('component:engine');
            }
            if (filenames.some(f => f.startsWith('src/store/'))) {
              labels.push('component:state');
            }
            if (filenames.some(f => f.startsWith('tests/') || f.includes('.test.') || f.includes('.spec.'))) {
              labels.push('ðŸ§ªTESTING');
            }
            if (filenames.some(f => f.startsWith('docs/') || f.endsWith('.md'))) {
              labels.push('documentation');
            }
            if (filenames.some(f => f.includes('package.json') || f.includes('package-lock.json') || f.includes('yarn.lock'))) {
              labels.push('dependencies');
            }
            if (filenames.some(f => f.includes('vite.config') || f.includes('tsconfig') || f.includes('.github/'))) {
              labels.push('component:build');
              labels.push('devops');
            }

            // DevOps and tooling detection
            if (filenames.some(f => f.includes('.github/workflows/') || f.includes('Dockerfile') || f.includes('docker-compose'))) {
              labels.push('ðŸ’‰DEVOPS');
            }

            // Security file detection
            if (filenames.some(f => f.includes('security') || f.includes('.env') || f.includes('secrets'))) {
              labels.push('ðŸ”’SECURITY');
            }

            // Size labels based on changes (using org Size labels)
            const totalChanges = files.reduce((sum, f) => sum + f.changes, 0);
            if (totalChanges < 10) {
              labels.push('size: XS');
            } else if (totalChanges < 50) {
              labels.push('size: S');
            } else if (totalChanges < 200) {
              labels.push('size: M');
            } else if (totalChanges < 500) {
              labels.push('size: L');
            } else {
              labels.push('size: XL');
            }

            // Remove duplicates
            const uniqueLabels = [...new Set(labels)];

            // Apply labels
            if (uniqueLabels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                labels: uniqueLabels
              });

              console.log(`Applied file-based labels: ${uniqueLabels.join(', ')}`);
            }

      - name: Auto-assign milestone (PRs only)
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            // Get all labels for the PR
            const { data: prData } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });

            const labelNames = prData.labels.map(l => l.name.toLowerCase());
            const title = prData.title.toLowerCase();
            const body = (prData.body || '').toLowerCase();

            // Milestone mapping based on labels and content
            // Milestone 1: Foundation (devops, build, config)
            // Milestone 2: Game Engine (engine, game logic)
            // Milestone 3: Core UI Components (ui components, cards, chips)
            // Milestone 4: Game Interface (game interface, layout)
            // Milestone 5: State Management (state, store, zustand)
            // Milestone 6: Animations & Polish (animations, framer motion)
            // Milestone 7: Audio & Accessibility (audio, a11y)
            // Milestone 8: Testing & QA (testing, qa, e2e)
            // Milestone 9: Documentation & Deployment (docs, deployment)

            let milestoneNumber = null;

            // Priority order - more specific first
            if (labelNames.some(l => l.includes('component:build') || l.includes('devops') || l.includes('ðŸ’‰devops')) ||
                title.includes('workflow') || title.includes('build') || title.includes('config') || title.includes('vite')) {
              milestoneNumber = 1; // Foundation
            } else if (labelNames.some(l => l.includes('component:engine')) ||
                       title.includes('engine') || title.includes('game logic') || body.includes('blackjack rules')) {
              milestoneNumber = 2; // Game Engine
            } else if (labelNames.some(l => l.includes('game:cards') || l.includes('game:betting') || l.includes('game:dealer')) ||
                       title.includes('card') || title.includes('chip') || title.includes('dealer')) {
              milestoneNumber = 3; // Core UI Components
            } else if (labelNames.some(l => l.includes('component:ui') || l.includes('front-end')) ||
                       title.includes('ui') || title.includes('interface') || title.includes('layout')) {
              milestoneNumber = 4; // Game Interface
            } else if (labelNames.some(l => l.includes('component:state')) ||
                       title.includes('state') || title.includes('store') || title.includes('zustand')) {
              milestoneNumber = 5; // State Management
            } else if (labelNames.some(l => l.includes('component:animation')) ||
                       title.includes('animation') || title.includes('framer') || title.includes('motion')) {
              milestoneNumber = 6; // Animations & Polish
            } else if (labelNames.some(l => l.includes('area:accessibility') || l.includes('area:audio')) ||
                       title.includes('accessibility') || title.includes('a11y') || title.includes('audio')) {
              milestoneNumber = 7; // Audio & Accessibility
            } else if (labelNames.some(l => l.includes('ðŸ§ªtesting') || l.includes('testing')) ||
                       title.includes('test') || title.includes('qa') || title.includes('e2e')) {
              milestoneNumber = 8; // Testing & QA
            } else if (labelNames.some(l => l.includes('documentation')) ||
                       title.includes('docs') || title.includes('documentation') || title.includes('deployment')) {
              milestoneNumber = 9; // Documentation & Deployment
            } else {
              // Default to Foundation for infrastructure/devops work
              milestoneNumber = 1;
            }

            if (milestoneNumber) {
              try {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  milestone: milestoneNumber
                });
                console.log(`Assigned to Milestone ${milestoneNumber}`);
              } catch (error) {
                console.error(`Failed to assign milestone: ${error.message}`);
              }
            }

      - name: Update status check - Success
        if: github.event_name == 'pull_request' && success()
        uses: actions/github-script@v7
        with:
          script: |
            const checkRunId = ${{ steps.status-check.outputs.check_run_id }};
            await github.rest.checks.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_run_id: checkRunId,
              status: 'completed',
              conclusion: 'success',
              output: {
                title: 'Auto Label - Success',
                summary: 'Labels have been successfully applied to this PR'
              }
            });

      - name: Update status check - Failure
        if: github.event_name == 'pull_request' && failure()
        uses: actions/github-script@v7
        with:
          script: |
            const checkRunId = ${{ steps.status-check.outputs.check_run_id }};
            await github.rest.checks.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_run_id: checkRunId,
              status: 'completed',
              conclusion: 'failure',
              output: {
                title: 'Auto Label - Failed',
                summary: 'Failed to apply labels to this PR. Check workflow logs for details.'
              }
            });
